<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SICAR Runner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }
        .game-container {
            touch-action: none;
        }
        canvas {
            background-color: #f7f7f7;
            border-bottom: 2px solid #333;
        }
    </style>
</head>
<body class="bg-gray-800 text-white flex items-center justify-center h-screen m-0">

    <div id="game-container" class="game-container w-full max-w-4xl text-center p-4">
        <h1 class="text-4xl md:text-5xl mb-2">SICAR Runner</h1>
        
        <div class="flex justify-between items-center text-lg md:text-2xl mb-4 px-2">
            <div>SCORE: <span id="score">0</span></div>
            <div>HI: <span id="high-score">0</span></div>
        </div>

        <div class="relative w-full aspect-[2/1] bg-white rounded-lg shadow-2xl overflow-hidden">
            <canvas id="gameCanvas"></canvas>
            <div id="start-screen" class="absolute inset-0 bg-black bg-opacity-60 flex flex-col items-center justify-center p-4">
                <p class="text-2xl md:text-4xl mb-4">¡Prepárate para correr!</p>
                <p class="text-lg md:text-xl mb-8">Presiona ESPACIO o toca la pantalla para saltar</p>
                <button id="start-button" class="bg-green-500 text-white font-bold py-3 px-8 rounded-lg text-2xl hover:bg-green-600 transition-colors duration-300">
                    Iniciar Juego
                </button>
            </div>
            <div id="game-over-screen" class="absolute inset-0 bg-black bg-opacity-60 flex-col items-center justify-center p-4 hidden">
                <p class="text-4xl md:text-6xl mb-4">GAME OVER</p>
                <button id="restart-button" class="bg-blue-500 text-white font-bold py-3 px-8 rounded-lg text-2xl hover:bg-blue-600 transition-colors duration-300">
                    Reiniciar
                </button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('high-score');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');

        // --- Image Assets ---
        // I'm using placeholder images here. You should replace the 'src' values
        // with the actual paths to your images if you host them somewhere,
        // or just use the filenames if they are in the same folder as the HTML file.
        const imageUrls = {
            playerRun1: 'correr.png',
            playerRun2: 'correr2.png',
            playerJump: 'jump.png',
        };

        const obstacleData = [
            { src: 'Bascula-SICAR-Mary3W_02.jpg', points: 13 },
            { src: 'Etiquetadora-Dora88s-B-trans.png', points: 13 },
            { src: 'Etiquetadora-EVA-Black-58-2.png', points: 13 },
            { src: 'Etiquetadora-QL800-2.jpg', points: 13 },
            { src: 'Imp-SICAR-WL88S-F.png', points: 13 },
            { src: 'SICAR-AndyD2-1.png', points: 13 },
            { src: 'Sicar-Hammbox-4-1.png', points: 13 },
            { src: 'comandero.JPG', points: 22 },
            { src: 'migra.PNG', points: 19 },
            { src: 'repo.PNG', points: 19 },
            { src: 'sellos.JPG', points: 5 },
            { src: 'sicar-movil.JPG', points: 5 },
            { src: 'correo.JPG', points: 5 },
        ];

        const images = {};
        let imagesLoaded = 0;
        const totalImages = 3 + obstacleData.length; // run1, run2, jump + obstacles

        function loadImages(callback) {
            function onImageLoad() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    callback();
                }
            }
            
            images.playerRun1 = new Image();
            images.playerRun1.src = imageUrls.playerRun1;
            images.playerRun1.onload = onImageLoad;
            images.playerRun1.onerror = () => { onImageLoad(); console.log(`Error loading ${imageUrls.playerRun1}`); };

            images.playerRun2 = new Image();
            images.playerRun2.src = imageUrls.playerRun2;
            images.playerRun2.onload = onImageLoad;
            images.playerRun2.onerror = () => { onImageLoad(); console.log(`Error loading ${imageUrls.playerRun2}`); };
            
            images.playerJump = new Image();
            images.playerJump.src = imageUrls.playerJump;
            images.playerJump.onload = onImageLoad;
            images.playerJump.onerror = () => { onImageLoad(); console.log(`Error loading ${imageUrls.playerJump}`); };

            images.obstacles = [];
            obstacleData.forEach(data => {
                const img = new Image();
                img.src = data.src;
                img.onload = onImageLoad;
                img.onerror = () => { onImageLoad(); console.log(`Error loading ${data.src}`); };
                images.obstacles.push({ image: img, points: data.points });
            });
        }
        
        // --- Game Variables ---
        let player, gravity, obstacles, gameSpeed, score, highScore, gameOver, spawnTimer;
        let groundHeight;
        let animationFrameId;
        let runFrame = 0;
        let floatingScores = [];

        // --- Game Setup ---
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            groundHeight = canvas.height - 70; // Adjust ground position
        }

        function init() {
            resizeCanvas();
            
            gravity = 0.7;
            obstacles = [];
            floatingScores = [];
            gameSpeed = 5;
            score = 0;
            highScore = localStorage.getItem('sicarRunnerHighScore') || 0;
            highScoreEl.innerText = highScore;
            gameOver = false;
            spawnTimer = 100; // Initial delay before first obstacle
        }

        // --- Player ---
        class Player {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.dy = 0;
                this.jumpPower = 15;
                this.grounded = true;
            }

            draw(ctx) {
                let currentImage;
                if (!this.grounded) {
                    currentImage = images.playerJump;
                } else {
                    currentImage = runFrame < 10 ? images.playerRun1 : images.playerRun2;
                }
                
                if (currentImage && currentImage.complete && currentImage.naturalHeight !== 0) {
                     ctx.drawImage(currentImage, this.x, this.y, this.width, this.height);
                } else {
                    // Fallback drawing if image fails to load
                    ctx.fillStyle = 'blue';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }

            update() {
                runFrame = (runFrame + 1) % 20;

                if (!this.grounded) {
                    this.dy += gravity;
                    this.y += this.dy;
                }

                if (this.y + this.height >= groundHeight) {
                    this.y = groundHeight - this.height;
                    this.dy = 0;
                    this.grounded = true;
                }
            }

            jump() {
                if (this.grounded) {
                    this.dy = -this.jumpPower;
                    this.grounded = false;
                }
            }
        }
        
        // --- Floating Score Effect ---
        class FloatingScore {
            constructor(x, y, value) {
                this.x = x;
                this.y = y;
                this.value = value;
                this.opacity = 1;
                this.lifespan = 60; // apx. 1 second
            }

            update() {
                this.y -= 0.8; // Float up
                this.lifespan--;
                this.opacity = this.lifespan / 60;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#1f2937'; // Dark gray color
                ctx.font = '20px "Press Start 2P"';
                ctx.fillText(this.value, this.x, this.y);
                ctx.restore();
            }
        }

        // --- Obstacles ---
        class Obstacle {
            constructor(x, y, width, height, image, points) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.image = image;
                this.points = points;
                this.passed = false; // To track if player cleared it
            }

            draw(ctx) {
                 if (this.image && this.image.complete && this.image.naturalHeight !== 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                } else {
                    // Fallback drawing
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }

            update() {
                this.x -= gameSpeed;
            }
        }
        
        function spawnObstacle() {
            spawnTimer--;
            if (spawnTimer <= 0) {
                const randomObstacleData = images.obstacles[Math.floor(Math.random() * images.obstacles.length)];
                const randomImage = randomObstacleData.image;
                const points = randomObstacleData.points;
                
                // Randomize obstacle size slightly
                const scale = 0.8 + Math.random() * 0.4; // 80% to 120% of base size
                const baseHeight = 50;
                const height = baseHeight * scale;
                // Ensure width is calculated only if image has loaded, otherwise default
                const width = (randomImage.naturalWidth > 0) ? (randomImage.width / randomImage.height) * height : 50;

                const newObstacle = new Obstacle(
                    canvas.width, 
                    groundHeight - height, 
                    width, 
                    height, 
                    randomImage,
                    points
                );
                obstacles.push(newObstacle);

                // Reset spawn timer with some randomness
                spawnTimer = 100 - gameSpeed * 4 - Math.random() * 40;
                if(spawnTimer < 40) spawnTimer = 40;
            }
        }

        function checkCollision(player, obstacle) {
            const padding = 5; // Make hitbox slightly smaller
            return (
                player.x + padding < obstacle.x + obstacle.width - padding &&
                player.x + player.width - padding > obstacle.x + padding &&
                player.y + padding < obstacle.y + obstacle.height - padding &&
                player.y + player.height - padding > obstacle.y + padding
            );
        }

        // --- Game Loop ---
        function animate() {
            if (gameOver) return;

            animationFrameId = requestAnimationFrame(animate);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update & Draw Player
            player.update();
            player.draw(ctx);
            
            // Spawn, Update & Draw Obstacles
            spawnObstacle();
            obstacles.forEach((obstacle, index) => {
                obstacle.update();
                obstacle.draw(ctx);

                // Check for successful jump and award points
                if (!obstacle.passed && obstacle.x + obstacle.width < player.x) {
                    const points = obstacle.points;
                    score += points;
                    floatingScores.push(new FloatingScore(player.x, player.y, `+${points}`));
                    obstacle.passed = true;
                }

                // Collision check
                if (checkCollision(player, obstacle)) {
                    endGame();
                }

                // Remove off-screen obstacles
                if (obstacle.x + obstacle.width < 0) {
                    obstacles.splice(index, 1);
                }
            });

            // Update and draw floating scores
            floatingScores.forEach((fs, index) => {
                fs.update();
                fs.draw(ctx);
                if (fs.opacity <= 0) {
                    floatingScores.splice(index, 1);
                }
            });

            // Update Score (distance) & Speed
            score++;
            scoreEl.innerText = Math.floor(score);
            if (score % 200 === 0) { // Increase speed a bit slower
                gameSpeed += 0.1;
            }
        }
        
        // --- Game State ---
        function startGame() {
            cancelAnimationFrame(animationFrameId);
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            
            init();
            player = new Player(50, groundHeight - 60, 50, 60);
            
            animate();
        }

        function endGame() {
            gameOver = true;
            cancelAnimationFrame(animationFrameId);
            gameOverScreen.classList.remove('hidden');

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('sicarRunnerHighScore', highScore);
                highScoreEl.innerText = highScore;
            }
        }

        // --- Event Listeners ---
        window.addEventListener('resize', () => {
             resizeCanvas();
             init(); // Re-initialize to adjust ground etc.
        });
        
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        document.addEventListener('keydown', e => {
            if (e.code === 'Space' || e.key === ' ' || e.code === 'ArrowUp') {
                e.preventDefault();
                if(!gameOver) player.jump();
            }
        });
        
        canvas.parentElement.addEventListener('mousedown', () => {
             if(!gameOver) player.jump();
        });
        
        canvas.parentElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if(!gameOver) player.jump();
        });

        // --- Initial Load ---
        loadImages(() => {
            console.log("All images loaded, game is ready.");
            init();
            player = new Player(50, groundHeight - 60, 50, 60);
            player.draw(ctx); // Draw initial player state
        });

    </script>
</body>
</html>



